'''A component-tree storing McPat's output for each component.

The component-tree generated by the parser matches the tree constructed by the
m5parser for input to the McPat simulator. However, instead of machine
parameters and usage stats, it stores the area, timing and power information of
each component.
'''

from copy import deepcopy

import parsetree

class UnknownType(Exception):
    def __init__(self, node):
        self.node = node

    def __str__(self):
        return "Parse-tree node of unknown type encountered: {0}\n\nData: {1}".format(self.node.typ, self.node.data)

class Component(object):
    '''A component class similar to m5parser's class Component

    Objects of this class form a tree-structure matching the component tree
    used to create the input XML file for McPat.'''

    def __init__(self, name, parent = None):
        self.name = name.upper()
        self.attributes = {}
        self.parameters = {}
        self.children = []
        self.parent = parent

    def addAttribute(self, name, value):
        '''Add attribute `name' with value = (value, unit).'''
        self.attributes[name] = value

    def addParam(self, name, param):
        '''Add parameter object named `name'.'''
        self.parameters[name] = param

    def addChild(self, child):
        self.children.append(child)

    def addChildren(self, children):
        self.children.extend(children)

    def isRoot(self):
        return not self.parent

    def __str__(self, indent=0):
        '''Create a string representation of the self with this instance as root.'''
        s = "{0}{1}\n".format(' '*indent, self.name)
        if self.__class__ == RootComponent:
            s += "{0}Meta Data\n".format(' '*(indent+2))
            for (key, value) in self.metaData.iteritems():
                s += "{0}{1} = {2}\n".format(' '*(indent+4), key, value)

        if len(self.parameters):
            s += "{0}Parameters\n".format(' '*(indent+2))
            for p in self.parameters.itervalues():
                s += p.__str__(indent+4)

        if len(self.attributes):
            s += "{0}Attributes\n".format(' '*(indent+2))
            for (key, value) in self.attributes.iteritems():
                s += "{0}{1} = {2}\n".format(' '*(indent+4), key, value)

        s += "\n"

        for child in self.children:
            s += child.__str__(indent+2)

        return s

class RootComponent(Component):
    def __init__(self):
        super(RootComponent, self).__init__('root', None)
        self.metaData = {}

    def addMetaData(self, name, value):
        '''Add meta-data `name' with value `value'.'''
        self.metaData[name] = value

class SystemComponent(Component):
    def __init__(self, parent):
        super(SystemComponent, self).__init__('system', parent)

class Parameter(Component):
    '''A parameter is just data-wise not really different from a component.'''
    pass

def createFromParseTree(parseTree):
    '''Converts a parse-tree to a component-tree.'''
    converter = ParseTreeToComponentTreeConverter()
    parseTree.visit(converter)
    return converter.root

class ParseTreeToComponentTreeConverter(parsetree.Visitor):
    def __init__(self):
        super(ParseTreeToComponentTreeConverter, self).__init__()
        self.root = RootComponent()
        self.system = SystemComponent(self.root)
        self.root.addChild(self.system)
        self.lastComponent = self.system

    def pushParent(self, node):
        self.parentStack.append(self.lastComponent)

    def visit(self, node):
        name = 'visit{0}{1}'.format(node.typ[0].upper(), node.typ[1:])
        try:
            f = getattr(self, name)
            f(node)
        except AttributeError, e:
            raise UnknownType(node)

    def visitRoot(self, node):
        pass

    def visitMetaData(self, node):
        # node.data = ('McPAT (version 0.8 of Aug, 2010) is computing the target processor...',)
        self.root.addMetaData(node.typ, node.data[0])

    def visitTechnology(self, node):
        # node.data = (('Technology', '90 nm'),)
        (name, value) = node.data[0]
        self.system.addAttribute(name, tuple(value.split()))

    def visitLongChannelDevices(self, node):
        # node.data = (('Using Long Channel Devices When Appropriate',),)
        self.root.addMetaData('LongChannelDevices', node.data[0][0])

    def visitInterconnectProjection(self, node):
        # node.data = (('Interconnect metal projection', 'aggressive interconnect technology projection'),)
        self.root.addMetaData('InterconnectMetalProjection', node.data[0][1])

    def visitClockRate(self, node):
        # node.data = (('Core clock Rate', '1200 MHz'),)
        value  = node.data[0][1]
        self.system.addAttribute('ClockRate', tuple(value.split()))

    def visitCreationTime(self, node):
        # node.data = ('config: 93.103 s',)
        words = node.data[0].split()
        self.root.addMetaData('CreationTime', ' '.join(words[1:]))

    def visitComputationTime(self, node):
        # node.data = ('request: 8.155 ms',)
        words = node.data[0].split()
        self.root.addMetaData('ComputationTime', ' '.join(words[1:]))

    def visitComponent(self, node):
        # node.data = (('Processor',),)
        name = node.data[0][0]
        parent = self.parentNode()
        c = Component(name.lower(), parent)
        parent.addChild(c)

        self.lastComponent = c

    def visitParameter(self, node):
        # node.data = (('Total Cores', '8 cores'),)
        (name, value) = node.data[0]
        parent = self.parentNode()
        name = name.lower()
        p = Parameter(name, parent)
        parent.addParam(name, p)

        # A parameter usually has one or more attributes.
        self.lastComponent = p

    def visitAttribute(self, node):
        # node.data = (('Area', '283.287 mm^2'),)
        (name, value) = node.data[0]

        # Device Typ ('Device Type', 'ITRS high performance device type')
        if name == 'Device Type':
            value = (value, '')
        else:
            value = tuple(value.split())

        parent = self.parentNode()
        parent.addAttribute(name, value)

class CompTreeTransform(object):
    '''Like the TreeTransform classes for the parse-tree.

    This is the base class for transforms operating on a component-tree.
    They're the same as the transforms on the parse-tree. Some tasks are more
    convenient to do on the parse-tree, others that need more information may
    be easier to do on the component-tree.
    '''

    def __init__(self, tree):
        self.tree = tree

    def findComponent(self, node, name):
        if node.name == name:
            return node

        for child in node.children:
            res = self.findComponent(child, name)
            if res:
                return res

        return None

    def pushDownChildren(self, node, child, children):
        for c in children:
            idx = node.children.index(c)
            child.addChild(c)
            del node.children[idx]

    def pullUpChildren(self, node, child, grandChildren):
        for grandChild in grandChildren:
            idx = child.children(grandChild)
            node.addChild(grandChild)
            del child.children[idx]

class GroupLocalPredictors(CompTreeTransform):
    '''Fixes inproper indentation of local predictors.

    Transforms the following McPat output

        Local Predictor:
        L1_Local Predictor:
          Area = 0.0148546 mm^2
          Peak Dynamic = 0.00478135 W
          Subthreshold Leakage = 0.000998488 W
          Gate Leakage = 0.000141272 W
          Runtime Dynamic = 3.43689e-06 W

        L2_Local Predictor:
          Area = 0.00713102 mm^2
          Peak Dynamic = 0.00256395 W
          Subthreshold Leakage = 0.00055152 W
          Gate Leakage = 8.34556e-05 W
          Runtime Dynamic = 1.84576e-06 W

    into the following properly indented format:

        Local Predictor:
            L1_Local Predictor:
              Area = 0.0148546 mm^2
              Peak Dynamic = 0.00478135 W
              Subthreshold Leakage = 0.000998488 W
              Gate Leakage = 0.000141272 W
              Runtime Dynamic = 3.43689e-06 W

            L2_Local Predictor:
              Area = 0.00713102 mm^2
              Peak Dynamic = 0.00256395 W
              Subthreshold Leakage = 0.00055152 W
              Gate Leakage = 8.34556e-05 W
              Runtime Dynamic = 1.84576e-06 W

    But remeber: this transform operates on the component-tree. The McPat
    output is only for illustration purposes!
    '''

    def transform(self):
        self.pushDownLocalPredictors(self.tree)
        return self.tree

    def pushDownLocalPredictors(self, node):
        i = 0
        while i < len(node.children):
            child = node.children[i]
            self.pushDownLocalPredictors(child)
            if child.name == 'LOCAL PREDICTOR':
                localPredictors = self.collectLocalPredictors(node, i+1)
                self.pushDownChildren(node, child, localPredictors)
            i += 1

    def collectLocalPredictors(self, node, start):
        preds = []
        for i in xrange(start, len(node.children)):
            child = node.children[i]
            if child.name.rfind('_LOCAL PREDICTOR') is not -1:
                preds.append(child)
            else:
                break
        return preds

class EnumerateComponents(CompTreeTransform):
    '''Enumerate for example core components.

    The standard McPat output does not enumerate the different cores (assuming
    heterogeneous cores). All cores are listed like the following one:

        Core:
              Area = 2.99698 mm^2
              Peak Dynamic = 0.765963 W
              Subthreshold Leakage = 0.403911 W
              Gate Leakage = 0.100484 W
              Runtime Dynamic = 0.0668918 W

    This transform appends to the name attribute of the core components a
    number, that corresponds to their position in the output. The i-th core
    component in the output corresponds to the i-th <component
    name="coreX">-section in the XML input file. NOTE: the number given in the
    name= oder id= attributes don't matter, the output corresponds to their
    order as they appear in the input file (don't blame me, I didn't write that)!
    '''

    def __init__(self, tree, name, enumerateSingleComponent = False):
        super(EnumerateComponents, self).__init__(tree)
        self.lastCore = None
        self.count = 0
        self.name = name
        self.enumerateSingleComponent = enumerateSingleComponent

    def transform(self):
        self.enumerateComponents(self.tree)

        # Remove the number if there is only a single core.
        if self.enumerateSingleComponent and self.lastCore and self.count is 1:
            self.lastCore.name = self.name

        return self.tree

    def enumerateComponents(self, node):
        for child in node.children:
            if child.name == self.name:
                self.lastCore = child
                child.name += str(self.count)
                self.count += 1
            self.enumerateComponents(child)

class ReplaceBusesWithChildren(CompTreeTransform):
    '''Replaces the BUSES component with its children.

    This transform is used to remove the BUSES section in McPat's output with
    the actual Bus components.
    '''

    def transform(self):
        self.replaceWithChildren(self.tree)
        return self.tree

    def replaceWithChildren(self, node):
        i = 0
        while i < len(node.children):
            child = node.children[i]
            self.replaceWithChildren(child)
            if child.name == 'BUSES':
                grandchilds = child.children
                node.children[i:i+1] = grandchilds
            else:
                i += 1


class MergeProcessorAndSystem(CompTreeTransform):
    '''Merges the PROCESSOR component into the SYSTEM component.

    This step is used to make the component-tree generated from the McPat
    output identical to the m5parser's component-tree.'''

    def transform(self):
        system = self.findComponent(self.tree, 'SYSTEM')
        processor = self.findComponent(self.tree, 'PROCESSOR')
        self.merge(system, processor)
        return self.tree

    def merge(self, system, processor):
        for (name,val) in processor.attributes.iteritems():
            system.addAttribute(name, val)

        for (name,val) in processor.parameters.iteritems():
            system.addParam(name,val)

        system.addChildren(processor.children)

        system.children.remove(processor)

class PullUpSubtree(CompTreeTransform):
    '''Promotes a grand-child of a node to a child of that node.'''
    def __init__(self, tree, componentName):
        super(PullUpSubtree, self).__init__(tree)
        self.componentName = componentName

    def transform(self):
        self.pullUpComponents(self.tree)
        return self.tree

    def pullUpComponents(self, node):

        myPromotees = []
        childrensPromotees = []

        for child in node.children:
            childrensPromotees.extend(self.pullUpComponents(child))
            if self.componentName == child.name:
                myPromotees.append(child)

        # Delete all children that are to be promoted.
        for promotee in myPromotees:
            node.children.remove(promotee)

        node.children.extend(childrensPromotees)

        return myPromotees

class SplitComponent(CompTreeTransform):
    '''Split a component into two components.

    If the node has children they're migrated to the first of the two new nodes.'''
    def __init__(self, tree, componentName, newComponentName1, newComponentName2):
        super(SplitComponent, self).__init__(tree)
        self.componentName = componentName
        self.newComponentName1 = newComponentName1
        self.newComponentName2 = newComponentName2

    def transform(self):
        self.splitComponents(self.tree)
        return self.tree

    def splitComponents(self, node):
        for child in node.children:
            self.splitComponents(child)
            if child.name == self.componentName:
                self.splitComponent(node, child)

    def splitComponent(self, parent, component):
        c1 = Component(self.newComponentName1, parent)
        c2 = Component(self.newComponentName2, parent)

        c1.parameters = deepcopy(component.parameters)
        c2.parameters = deepcopy(component.parameters)

        # Add the children only to one of the new nodes
        c1.children = component.children

        # Splitt all attributes in half
        newAttribs = self.splitAttribsInHalf(component.attributes)

        c1.attributes = deepcopy(newAttribs)
        c2.attributes = deepcopy(newAttribs)

        parent.children.remove(component)
        parent.addChild(c1)
        parent.addChild(c2)

    def splitAttribsInHalf(self, attributes):
        newAttribs = {}
        for (key, val) in attributes.iteritems():
            halfVal = self.halfValue(val)
            newAttribs[key] = halfVal
        return newAttribs

    def halfValue(self, value):
        (val, unit) = value
        halfVal = float(val)/2
        return (str(halfVal), unit)






#########################################################################################
##  Transforms
#########################################################################################

def groupLocalPredictors(tree):
    ''''See documentation of GroupLocalPredictors.'''
    t = GroupLocalPredictors(tree)
    return t.transform()

def enumerateCores(tree):
    '''See documentation of EnumerateComponents.'''
    t = EnumerateComponents(tree, 'CORE', True)
    return t.transform()

def enumerateL1Dirs(tree):
    '''Enumerate L1 directories.'''
    t = EnumerateComponents(tree, 'FIRST LEVEL DIRECTORY')
    return t.transform()

def replaceBusesWithBusComponents(tree):
    '''Remove the BUSES component.'''
    t = ReplaceBusesWithChildren(tree)
    return t.transform()

def mergeProcessorAndSystem(tree):
    '''Merge the PROCESSOR component into the SYSTEM  component.'''
    t = MergeProcessorAndSystem(tree)
    return t.transform()

def pullUpBranchTargetBuffer(tree):
    '''Pull up the BTB component from the IFU.'''
    t = PullUpSubtree(tree, 'BRANCH TARGET BUFFER')
    return t.transform()

def pullUpBranchPredictor(tree):
    '''Pull up the branch predictor component from the IFU.'''
    t = PullUpSubtree(tree, 'BRANCH PREDICTOR')
    return t.transform()

def pullUpItlb(tree):
    '''Pull up the ITLB component from the MMU.'''
    t = PullUpSubtree(tree, 'ITLB')
    return t.transform()

def pullUpDtlb(tree):
    '''Pull up the DTLB component from the MMU.'''
    t = PullUpSubtree(tree, 'DTLB')
    return t.transform()

def splitLoadStoreQueue(tree):
    '''Split combined load/store queue into a load and a store queue.'''
    t = SplitComponent(tree, 'LOAD/STORE QUEUE', 'LOADQ', 'STOREQ')
    return t.transform()

def pullUpRegisterFiles(tree):
    '''Pull up int and float register files from REGISTER FILES.'''
    t = PullUpSubtree(tree, 'INTEGER RF')
    tree = t.transform()
    t = PullUpSubtree(tree, 'FLOATING POINT RF')
    return t.transform()
