'''Translators to correlate the parser-tree with m5parser's component-tree.

The translators defined in this module correlate a node in this
McPat-output-parser generated component-tree with the nodes in the
component-tree generated by the m5parser module. They also include a function
to import the data in the m5parser's component-tree.
'''

from patdata import PatData

class UnknownComponent(Exception):
    def __init__(self, component):
        self.component = component

    def __str__(self):
        return "Unknown component '{0}'".format(self.component.name)

class TranslatorFactory(object):
    @staticmethod
    def create(parseTreeNode, options):
        '''Creates a translator for the given parser-tree node.'''
        name = parseTreeNode.name

        if name == 'ROOT':
            return RootTranslator(parseTreeNode)
        elif name == 'SYSTEM':
            return Translator(parseTreeNode)
        elif name.startswith('CORE'):
            return createCpuTranslator(parseTreeNode, options.cpu_name)
        elif name.startswith('FIRST LEVEL DIRECTORY'):
            return EnumeratedCompTranslator(parseTreeNode, 'FIRST LEVEL DIRECTORY', 'L1Directory')
        elif name == 'BRANCH PREDICTOR':
            return SubstitutionTranslator(parseTreeNode, 'PBT')
        elif name == 'BRANCH TARGET BUFFER':
            return SubstitutionTranslator(parseTreeNode, 'BTB')
        elif name == 'INSTRUCTION FETCH UNIT':
            return SubstitutionTranslator(parseTreeNode, 'ifu')
        elif name == 'INSTRUCTION CACHE':
            return SubstitutionTranslator(parseTreeNode, 'icache')
        elif name == 'LOAD STORE UNIT':
            return SubstitutionTranslator(parseTreeNode, 'lsu')
        elif name == 'DATA CACHE':
            return SubstitutionTranslator(parseTreeNode, 'dcache')
        elif name == 'LOADQ':
            return SubstitutionTranslator(parseTreeNode, 'loadqueue')
        elif name == 'STOREQ':
            return SubstitutionTranslator(parseTreeNode, 'storequeue')
        elif name == 'ITLB':
            return SubstitutionTranslator(parseTreeNode, 'itb')
        elif name == 'DTLB':
            return SubstitutionTranslator(parseTreeNode, 'dtb')
        elif name == 'MEMORY CONTROLLER':
            return SubstitutionTranslator(parseTreeNode, 'mc')
        elif name == 'EXECUTION UNIT':
            return SubstitutionTranslator(parseTreeNode, 'execunit')
        elif name == 'INTEGER RF':
            return SubstitutionTranslator(parseTreeNode, 'intrf')
        elif name == 'FLOATING POINT RF':
            return SubstitutionTranslator(parseTreeNode, 'floatrf')
        elif name == 'INSTRUCTION SCHEDULER':
            return SubstitutionTranslator(parseTreeNode, 'scheduler')
        elif name == 'INSTRUCTION WINDOW':
            return SubstitutionTranslator(parseTreeNode, 'window')
        elif name == 'FP INSTRUCTION WINDOW':
            return SubstitutionTranslator(parseTreeNode, 'fpwindow')
        elif name.startswith('INTEGER ALUS'):
            return SubstitutionTranslator(parseTreeNode, 'alu')
        elif name.startswith('FLOATING POINT UNITS'):
            return SubstitutionTranslator(parseTreeNode, 'fpu')
        elif name == 'L2':
            return Translator(parseTreeNode)
        elif name == 'BUS':
            return BusTranslator(parseTreeNode)
        else:
            return UntranslatableComponent()

    @staticmethod
    def filterOut(compTreeNode, options):
        '''Tests if a component-tree node has a related parse-tree node.

        This function takes as input an instance of class Component of the
        m5parser. It determines if McPat produces some output for the given
        node.
        '''

        # Elements of FILTERS can either be a string or a boolean function that
        # takes the compTreeNode as sole argument.
        # If any of the filters is true for a given compTreeNode the parser
        # will not look for a matching parse tree node from McPat's output.
        FILTERS = [
            'badaddr_responder',
            'bridge',
            'flashc',
            'fuPool',
            'interrupts',
            'intrctrl',
            'iobridge',
            'iobus',
            'iocache',
            'membus',
            'niu',
            'pcie',
            'physmem',
            'tracer',
            'terminal',
            'tsunami',
            'walker',
            'acpi_description_table_pointer',
            'apicbridge',
            'e820_table',
            'intel_mp_pointer',
            'intel_mp_table',
            'pc',
            'smbios_table',
            'itb_walker_cache',
            'dtb_walker_cache',
            'realview',
            'vncserver',
            lambda x: 'disk' in x.name or 'disk' in x.params['type'].lower()
        ]

        for filter in FILTERS:
            if callable(filter):
                if filter(compTreeNode):
                    return True
            elif compTreeNode.name == filter:
                return True

        # Filter all cpus that don't have options.cpu_name in their name. This
        # is necessary for switch cpu configurations.
        if 'cpu' in compTreeNode.params['type'].lower() and not options.cpu_name in compTreeNode.name:
            return True

        return False

    @staticmethod
    def isOptional(compTreeNode):
        '''Returns true if PAT data for a node is optional.

        Depending on the configuration used to run M5 McPat may or may not
        output PAT data for a node in the m5mbridge's component tree. In case
        no PAT output was found for a given node this function can be used to
        test if that is a fatal condition.
        '''
        OPTIONAL_COMPONENTS = [
            'window',
            'fpwindow'
        ]

        return compTreeNode.name in OPTIONAL_COMPONENTS

def createCpuTranslator(parseTreeNode, cpu_name):
    # For a single component Gem5 does not use any form of enumeration, for
    # example it uses cpu instead of cpu0.
    import re
    if re.search('[0-9]$', parseTreeNode.name):
        return EnumeratedCompTranslator(parseTreeNode, 'CORE', cpu_name)
    return SubstitutionTranslator(parseTreeNode, cpu_name)

class Translator(object):
    def __init__(self, parseTreeNode, skipChildren = False):
        self.parseTreeNode = parseTreeNode
        self.skipChildren = skipChildren

    def match(self, compTreeNode):
        '''Checks if `compTreeNode' refers to the same component as parseTreeNode.'''
        return self.matchByName(compTreeNode)

    def extend(self, compTreeNode):
        '''Imports the McPat-data stored in `parseTreeNode' into `compTreeNode'.'''
        compTreeNode.pat = PatData(self.parseTreeNode.attributes)

    def matchByName(self, compTreeNode):
        return self.parseTreeNode.name == compTreeNode.name.upper()

class UntranslatableComponent(Translator):
    def __init__(self):
        super(UntranslatableComponent, self).__init__(None)

    def match(self, compTreeNode):
        return False

    def extend(self, compTreeNode):
        pass

class NopTranslator(Translator):
    '''A translator that does simply nothing.'''
    def __init__(self):
        from m5mbridge.machine.component import Component
        super(NopTranslator, self).__init__(Component('a.dummy', {'type':'DUMMY'}, 'adummy'))

    def match(self, compTreeNode):
        return True

    def extend(self, compTreeNode):
        pass

class SubstitutionTranslator(Translator):
    '''Corelates two components by names for each of them.

    This translator is used for example to correlate mc and MEMORY CONTROLLER.
    '''

    def __init__(self, parseTreeNode, compTreeNodeName, skipChildren = False):
        super(SubstitutionTranslator, self).__init__(parseTreeNode, skipChildren)
        self.compTreeNodeName = compTreeNodeName

    def match(self, compTreeNode):
        return self.compTreeNodeName == compTreeNode.name

class RootTranslator(Translator):
    def extend(self, compTreeNode):
        pass

class EnumeratedCompTranslator(Translator):
    '''Translates components that appear multiple times in the input and output, e.g., cpu cores.

    The constructor takes two names. The parseName ist the name use in the tree
    generated from McPat's output and compName is the name used in the
    component tree generated by the m5parser.
    '''

    def __init__(self, parseTreeNode, parseName, compName):
        super(EnumeratedCompTranslator, self).__init__(parseTreeNode)
        self.parseName = parseName
        self.compName = compName
        self.parseNameIdx = int(self.parseTreeNode.name.replace(self.parseName, ''))

    def match(self, compTreeNode):
        # In Gem5 the CPU cores are enumerated as cpu0, cpu1, etc. and in McPat
        # they're enumerated as core0, core1, etc.
        try:
            compNameIdx = int(compTreeNode.name.replace(self.compName, ''))
            return compTreeNode.name.startswith(self.compName) and self.parseNameIdx == compNameIdx
        except Exception, e:
            return False

class BusTranslator(Translator):
    '''This works only for a single bus.

    I believe that the m5parser does not support more than one bus and I'm not
    sure if a typical Gem5 machine ever has more than a single bus. If it does,
    adjust this translator.

    Update 05 Apr 2012: The m5parser only exports the toL2Bus (and probably the
    toL3Bus). The problem is that McPat does not include anything in its
    output that allows us to map it back to the input components. To handle
    more than one bus, the McPat output format needs to include an
    identifier like the name attribute of each bus component from the XML
    input file.
    '''

    def match(self, compTreeNode):
        # get() defaults to None, if params has no 'type' key
        return compTreeNode.params.get('type') in ['Bus', 'CoherentBus']
